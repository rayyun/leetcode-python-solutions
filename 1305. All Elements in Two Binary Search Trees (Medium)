# https://leetcode.com/problems/all-elements-in-two-binary-search-trees/

# Solution 1 - Inorder Traversal Recursion + Two pointer sort
# O(n + m) / O(n + m)
class Solution:
    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:
        def inorder(node, nums):
            if node:
                inorder(node.left, nums)
                nums.append(node.val)
                inorder(node.right, nums)
            
            return nums
        
        def merge_two(nums1, nums2): 
            if not nums1:
                return nums2
            if not nums2:
                return nums1
            
            i, j = len(nums1) - 1, len(nums2) - 1
            nums1 += [float('-inf')] * len(nums2)
            p = len(nums1) - 1

            print(i, j, p)

            while j >= 0 and p >= 0:
                if i >= 0:
                    if nums1[i] >= nums2[j]:
                        nums1[p], nums1[i] = nums1[i], nums1[p]
                        i -= 1
                    else:
                        nums1[p] = nums2[j]
                        j -= 1
                else:
                    if nums1[p] < nums2[j]:
                        nums1[p] = nums2[j]
                        j -= 1
                
                p -= 1
                
            return nums1
                
                
        nums1 = inorder(root1, [])
        nums2 = inorder(root2, [])

        return merge_two(nums1, nums2)
        


# Solution 2 - Inorder Traversal Iteration + Two pointer sort
# O(n + m) / O(n + m)
class Solution:
    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:
        def inorder(node):
            if not node:
                return 
            
            res, stack = [], []
            
            while node or stack:
                if node:
                    stack.append(node)
                    node = node.left
                else:
                    node = stack.pop()
                    res.append(node.val)
                    node = node.right
                    
            return res
            
        
        def merge_two(nums1, nums2): 
            if not nums1:
                return nums2
            if not nums2:
                return nums1
            
            i, j = len(nums1) - 1, len(nums2) - 1
            nums1 += [float('-inf')] * len(nums2)
            p = len(nums1) - 1

            while j >= 0 and p >= 0:
                if i >= 0:
                    if nums1[i] >= nums2[j]:
                        nums1[p], nums1[i] = nums1[i], nums1[p]
                        i -= 1
                    else:
                        nums1[p] = nums2[j]
                        j -= 1
                else:
                    if nums1[p] < nums2[j]:
                        nums1[p] = nums2[j]
                        j -= 1
                
                p -= 1
                
            return nums1
                
                
        nums1 = inorder(root1)
        nums2 = inorder(root2)

        return merge_two(nums1, nums2)



# Solution 3 - Brute Force
# O((n+m)*log(n+m)) / O(n+m)
class Solution:
    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:
        def inorder(node):
            if not node:
                return []
            
            return inorder(node.left) + [node.val] + inorder(node.right)
        
        nums1 = inorder(root1)
        nums2 = inorder(root2)
        
        return sorted(nums1 + nums2)
